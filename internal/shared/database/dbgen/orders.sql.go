// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package dbgen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    order_number, user_id, status, address_id, address_snapshot, 
    subtotal_price, shipping_price, total_price, note, placed_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
RETURNING id, order_number, user_id, status, payment_method, payment_status, address_snapshot, subtotal_price, discount_price, shipping_price, total_price, note, placed_at, paid_at, cancelled_at, cancel_reason, completed_at, receipt_no, snap_token, snap_redirect_url, created_at, updated_at, deleted_at, address_id
`

type CreateOrderParams struct {
	OrderNumber     string          `json:"order_number"`
	UserID          uuid.UUID       `json:"user_id"`
	Status          string          `json:"status"`
	AddressID       uuid.NullUUID   `json:"address_id"`
	AddressSnapshot json.RawMessage `json:"address_snapshot"`
	SubtotalPrice   string          `json:"subtotal_price"`
	ShippingPrice   string          `json:"shipping_price"`
	TotalPrice      string          `json:"total_price"`
	Note            sql.NullString  `json:"note"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.queryRow(ctx, q.createOrderStmt, createOrder,
		arg.OrderNumber,
		arg.UserID,
		arg.Status,
		arg.AddressID,
		arg.AddressSnapshot,
		arg.SubtotalPrice,
		arg.ShippingPrice,
		arg.TotalPrice,
		arg.Note,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.UserID,
		&i.Status,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.AddressSnapshot,
		&i.SubtotalPrice,
		&i.DiscountPrice,
		&i.ShippingPrice,
		&i.TotalPrice,
		&i.Note,
		&i.PlacedAt,
		&i.PaidAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CompletedAt,
		&i.ReceiptNo,
		&i.SnapToken,
		&i.SnapRedirectUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AddressID,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO order_items (
    order_id, product_id, name_snapshot, unit_price, quantity, total_price
) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateOrderItemParams struct {
	OrderID      uuid.UUID `json:"order_id"`
	ProductID    uuid.UUID `json:"product_id"`
	NameSnapshot string    `json:"name_snapshot"`
	UnitPrice    string    `json:"unit_price"`
	Quantity     int32     `json:"quantity"`
	TotalPrice   string    `json:"total_price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.exec(ctx, q.createOrderItemStmt, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.NameSnapshot,
		arg.UnitPrice,
		arg.Quantity,
		arg.TotalPrice,
	)
	return err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT 
    o.id,
    o.order_number,
    o.user_id,
    o.status,
    o.payment_method,
    o.payment_status,
    o.address_snapshot,
    o.subtotal_price,
    o.discount_price,
    o.shipping_price,
    o.total_price,
    o.note,
    o.placed_at,
    o.paid_at,
    o.cancelled_at,
    o.cancel_reason,
    o.completed_at,
    o.receipt_no,
    o.snap_token,
    o.snap_redirect_url,
    (
        SELECT COALESCE(
            jsonb_agg(
                jsonb_build_object(
                    'id', oi.id,
                    'productId', oi.product_id,
                    'nameSnapshot', oi.name_snapshot,
                    'unitPrice', oi.unit_price,
                    'quantity', oi.quantity,
                    'subtotal', oi.total_price
                )
            ),
            '[]'::jsonb
        )
        FROM order_items oi
        WHERE oi.order_id = o.id
    )::jsonb AS items_json
FROM orders o
WHERE o.id = $1 
  AND o.deleted_at IS NULL
LIMIT 1
`

type GetOrderByIDRow struct {
	ID              uuid.UUID       `json:"id"`
	OrderNumber     string          `json:"order_number"`
	UserID          uuid.UUID       `json:"user_id"`
	Status          string          `json:"status"`
	PaymentMethod   sql.NullString  `json:"payment_method"`
	PaymentStatus   string          `json:"payment_status"`
	AddressSnapshot json.RawMessage `json:"address_snapshot"`
	SubtotalPrice   string          `json:"subtotal_price"`
	DiscountPrice   string          `json:"discount_price"`
	ShippingPrice   string          `json:"shipping_price"`
	TotalPrice      string          `json:"total_price"`
	Note            sql.NullString  `json:"note"`
	PlacedAt        time.Time       `json:"placed_at"`
	PaidAt          sql.NullTime    `json:"paid_at"`
	CancelledAt     sql.NullTime    `json:"cancelled_at"`
	CancelReason    sql.NullString  `json:"cancel_reason"`
	CompletedAt     sql.NullTime    `json:"completed_at"`
	ReceiptNo       sql.NullString  `json:"receipt_no"`
	SnapToken       sql.NullString  `json:"snap_token"`
	SnapRedirectUrl sql.NullString  `json:"snap_redirect_url"`
	ItemsJson       json.RawMessage `json:"items_json"`
}

func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (GetOrderByIDRow, error) {
	row := q.queryRow(ctx, q.getOrderByIDStmt, getOrderByID, id)
	var i GetOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.UserID,
		&i.Status,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.AddressSnapshot,
		&i.SubtotalPrice,
		&i.DiscountPrice,
		&i.ShippingPrice,
		&i.TotalPrice,
		&i.Note,
		&i.PlacedAt,
		&i.PaidAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CompletedAt,
		&i.ReceiptNo,
		&i.SnapToken,
		&i.SnapRedirectUrl,
		&i.ItemsJson,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT 
    id, 
    order_id, 
    product_id, 
    name_snapshot, 
    unit_price, 
    quantity, 
    total_price
FROM order_items 
WHERE order_id = $1
`

type GetOrderItemsRow struct {
	ID           uuid.UUID `json:"id"`
	OrderID      uuid.UUID `json:"order_id"`
	ProductID    uuid.UUID `json:"product_id"`
	NameSnapshot string    `json:"name_snapshot"`
	UnitPrice    string    `json:"unit_price"`
	Quantity     int32     `json:"quantity"`
	TotalPrice   string    `json:"total_price"`
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.query(ctx, q.getOrderItemsStmt, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.NameSnapshot,
			&i.UnitPrice,
			&i.Quantity,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT 
    o.id,
    o.order_number,
    o.status,
    o.total_price,
    o.placed_at,
    o.user_id,
    COUNT(*) OVER() AS total_count,
    (
        SELECT COALESCE(
            jsonb_agg(
                jsonb_build_object(
                    'id', oi.id,
                    'productId', oi.product_id,
                    'nameSnapshot', oi.name_snapshot,
                    'unitPrice', oi.total_price,
                    'quantity', oi.quantity,
                    'subtotal', oi.total_price * oi.quantity
                )
            ),
            '[]'::jsonb
        )
        FROM order_items oi
        WHERE oi.order_id = o.id
    )::jsonb AS items_json
FROM orders o
WHERE o.user_id = $3
  AND (
      $4::text IS NULL
      OR o.status = $4::text
  )
ORDER BY o.placed_at DESC
LIMIT $1 OFFSET $2
`

type ListOrdersParams struct {
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
	UserID uuid.UUID      `json:"user_id"`
	Status sql.NullString `json:"status"`
}

type ListOrdersRow struct {
	ID          uuid.UUID       `json:"id"`
	OrderNumber string          `json:"order_number"`
	Status      string          `json:"status"`
	TotalPrice  string          `json:"total_price"`
	PlacedAt    time.Time       `json:"placed_at"`
	UserID      uuid.UUID       `json:"user_id"`
	TotalCount  int64           `json:"total_count"`
	ItemsJson   json.RawMessage `json:"items_json"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]ListOrdersRow, error) {
	rows, err := q.query(ctx, q.listOrdersStmt, listOrders,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersRow
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.Status,
			&i.TotalPrice,
			&i.PlacedAt,
			&i.UserID,
			&i.TotalCount,
			&i.ItemsJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersAdmin = `-- name: ListOrdersAdmin :many
SELECT o.id, o.order_number, o.user_id, o.status, o.payment_method, o.payment_status, o.address_snapshot, o.subtotal_price, o.discount_price, o.shipping_price, o.total_price, o.note, o.placed_at, o.paid_at, o.cancelled_at, o.cancel_reason, o.completed_at, o.receipt_no, o.snap_token, o.snap_redirect_url, o.created_at, o.updated_at, o.deleted_at, o.address_id, count(*) OVER() AS total_count
FROM orders o
WHERE o.deleted_at IS NULL
  AND ($3::text IS NULL OR o.status = $3::text)
  AND ($4::text IS NULL OR o.order_number ILIKE '%' || $4::text || '%')
ORDER BY o.placed_at DESC
LIMIT $1 OFFSET $2
`

type ListOrdersAdminParams struct {
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
	Status sql.NullString `json:"status"`
	Search sql.NullString `json:"search"`
}

type ListOrdersAdminRow struct {
	ID              uuid.UUID       `json:"id"`
	OrderNumber     string          `json:"order_number"`
	UserID          uuid.UUID       `json:"user_id"`
	Status          string          `json:"status"`
	PaymentMethod   sql.NullString  `json:"payment_method"`
	PaymentStatus   string          `json:"payment_status"`
	AddressSnapshot json.RawMessage `json:"address_snapshot"`
	SubtotalPrice   string          `json:"subtotal_price"`
	DiscountPrice   string          `json:"discount_price"`
	ShippingPrice   string          `json:"shipping_price"`
	TotalPrice      string          `json:"total_price"`
	Note            sql.NullString  `json:"note"`
	PlacedAt        time.Time       `json:"placed_at"`
	PaidAt          sql.NullTime    `json:"paid_at"`
	CancelledAt     sql.NullTime    `json:"cancelled_at"`
	CancelReason    sql.NullString  `json:"cancel_reason"`
	CompletedAt     sql.NullTime    `json:"completed_at"`
	ReceiptNo       sql.NullString  `json:"receipt_no"`
	SnapToken       sql.NullString  `json:"snap_token"`
	SnapRedirectUrl sql.NullString  `json:"snap_redirect_url"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	DeletedAt       sql.NullTime    `json:"deleted_at"`
	AddressID       uuid.NullUUID   `json:"address_id"`
	TotalCount      int64           `json:"total_count"`
}

func (q *Queries) ListOrdersAdmin(ctx context.Context, arg ListOrdersAdminParams) ([]ListOrdersAdminRow, error) {
	rows, err := q.query(ctx, q.listOrdersAdminStmt, listOrdersAdmin,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersAdminRow
	for rows.Next() {
		var i ListOrdersAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.UserID,
			&i.Status,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.AddressSnapshot,
			&i.SubtotalPrice,
			&i.DiscountPrice,
			&i.ShippingPrice,
			&i.TotalPrice,
			&i.Note,
			&i.PlacedAt,
			&i.PaidAt,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CompletedAt,
			&i.ReceiptNo,
			&i.SnapToken,
			&i.SnapRedirectUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AddressID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders 
SET status = $2::text, 
    updated_at = NOW(),
    completed_at = CASE WHEN $2::text = 'COMPLETED' THEN NOW() ELSE completed_at END,
    cancelled_at = CASE WHEN $2::text = 'CANCELLED' THEN NOW() ELSE cancelled_at END
WHERE id = $1
RETURNING id, order_number, user_id, status, payment_method, payment_status, address_snapshot, subtotal_price, discount_price, shipping_price, total_price, note, placed_at, paid_at, cancelled_at, cancel_reason, completed_at, receipt_no, snap_token, snap_redirect_url, created_at, updated_at, deleted_at, address_id
`

type UpdateOrderStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.queryRow(ctx, q.updateOrderStatusStmt, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.UserID,
		&i.Status,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.AddressSnapshot,
		&i.SubtotalPrice,
		&i.DiscountPrice,
		&i.ShippingPrice,
		&i.TotalPrice,
		&i.Note,
		&i.PlacedAt,
		&i.PaidAt,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CompletedAt,
		&i.ReceiptNo,
		&i.SnapToken,
		&i.SnapRedirectUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AddressID,
	)
	return i, err
}
